[1mdiff --git a/heap_storage.cpp b/heap_storage.cpp[m
[1mindex 80d4ac2..4c9aeeb 100644[m
[1m--- a/heap_storage.cpp[m
[1m+++ b/heap_storage.cpp[m
[36m@@ -110,19 +110,43 @@[m [mvoid SlottedPage::put(RecordID record_id, const Dbt &data) {[m
         if(!has_room(extra_space)) {[m
             throw new DbBlockNoRoomError("Not enough room in block");[m
         }[m
[32m+[m[32m        // handle loc = 0, when the record had been deleted[m
[32m+[m[32m        // get the virtual curr_loc based on record id that comes after that id[m
[32m+[m[32m        // loop through all ids[m
[32m+[m[32m        if (curr_loc == 0) {[m
[32m+[m[32m            for (auto const& id: *ids()) {[m
[32m+[m[32m                if (id > record_id) {[m
[32m+[m[32m                    u16 temp_size, temp_loc;[m
[32m+[m[32m                    get_header(temp_size, temp_loc, id);[m
[32m+[m[32m                    if (temp_size > 0) {[m
[32m+[m[32m                        curr_loc = temp_loc + temp_size;[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // what if all records were deleted? get end_free + 1[m
[32m+[m[32m        if (curr_loc == 0) {[m
[32m+[m[32m            curr_loc = end_free + 1;[m
[32m+[m[32m        }[m
[32m+[m
         // slide right to left[m
[31m-        slide(curr_loc + new_size, curr_loc + curr_size);[m
[32m+[m[32m        slide(curr_loc, curr_loc - extra_space);[m
         // update block[m
         std::memcpy(this->address(curr_loc - extra_space), data.get_data(), new_size);[m
[32m+[m[32m        curr_loc = curr_loc - extra_space;[m
     }[m
     else { // new_size is smaller[m
         // update block[m
[31m-        std::memcpy(this->address(curr_loc), data.get_data(), new_size);[m
[32m+[m[32m        u16 new_loc = curr_loc + curr_size - new_size;[m
[32m+[m[32m        std::memcpy(this->address(new_loc), data.get_data(), new_size);[m
         // slide from left to right[m
[31m-        slide(curr_loc + new_size, curr_loc + curr_size);[m
[32m+[m[32m        slide(curr_loc, curr_loc + (curr_size - new_size));[m
[32m+[m[32m        curr_loc = curr_loc + (curr_size - new_size);[m
     }[m
     // slide function updates headers, so grab header info again[m
[31m-    get_header(curr_size, curr_loc, record_id);[m
[32m+[m[32m    // get_header(curr_size, curr_loc, record_id);[m
     put_header(record_id, new_size, curr_loc);[m
 }[m
 [m
[36m@@ -179,7 +203,7 @@[m [mbool SlottedPage::has_room(u_int16_t size) {[m
 }[m
 [m
 void SlottedPage::slide(u_int16_t start, u_int16_t end) {[m
[31m-    u16 shift = end - start;[m
[32m+[m[32m    int shift = end - start;[m
 [m
     if(shift == 0) {[m
         return;[m
[36m@@ -188,11 +212,14 @@[m [mvoid SlottedPage::slide(u_int16_t start, u_int16_t end) {[m
     // slide records from right to left[m
     // if shift is positive, we have space left-over[m
     // slide records from left to right[m
[32m+[m
[32m+[m[32m    // move_loc is where the last record starts[m
     u16 move_loc = this->end_free + 1;[m
     // TODO Verify this revision[m
[31m-    // u16 move_size = (start - 1) - move_loc; // legacy code[m
[32m+[m[32m    // FIXME: not deduct 1[m
[32m+[m[32m    u16 move_size = start - move_loc; // legacy code[m
     // u16 move_size = (start + 1) - move_loc; // revision[m
[31m-    u16 move_size = start - this->end_free; // revision[m
[32m+[m[32m    // u16 move_size = start - this->end_free; // revision[m
     u16 new_loc = move_loc + shift;[m
     // current records;[m
     Dbt temp_data(this->address(move_loc), move_size);[m
[36m@@ -206,7 +233,7 @@[m [mvoid SlottedPage::slide(u_int16_t start, u_int16_t end) {[m
     for (auto const& record_id: *ids()) {[m
         get_header(size, loc, record_id);[m
         // for ids loc <= start, we add the shift[m
[31m-        if(loc <= start) {[m
[32m+[m[32m        if(loc != 0 && loc <= start) {[m
             loc += shift;[m
             put_header(record_id, size, loc);[m
         }[m
